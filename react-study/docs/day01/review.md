## 📝 문제 해결

### ☑️ 요구사항
- /api/users에서 유저 리스트를 가져온다.
- 검색창에 이름을 입력하면, 해당 이름이 포함된 유저만 리스트에 나타난다.
- 유저 리스트는 아래와 같은 정보로 구성된다.
  - 이름
  - 이메일
  - 등록일 (YYYY-MM-DD)
- 리스트는 이름 오름차순으로 정렬되어 있어야 한다.
- 검색 키워드와 일치하는 텍스트는 하이라이팅 처리되어야 한다.

### 🎈 추가 요구사항
- 검색어 디바운싱(300ms)을 추가한다.
- 에러 발생 시 사용자에게 메시지를 출력해준다.

### 1. /api/users에서 유저리스트 가져오기
- MSW 설치 및 사용 방법 학습하기
- MSW 사용으로 Mock API 사용하기

리스트는 이름 오름차순으로 정렬되어있어야 하는데, MSW는 쿼리 파라미터 요청도 쉽게 처리할 수 있고 fetch 요청도 가능하기 때문에 MSW를 선택했다.

### 2. 검색창 입력 시 유저 리스트 보여주기
리스트를 오름차순으로 가져오는 것은 구현할 수 있지만 검색어와 일치하는 유저를 보여주는 것을 어떻게 구현할지 고민되었다.

- 소규모 데이터라면 클라이언트가 모든 데이터를 받아온 후 필터링할 수 있다.
- 대규모 데이터라면 클라이언트가 모든 데이터를 받아와 필터링하는 것은 비효율적이고 느리다.

만든 데이터는 몇개 안되기 때문에 클라이언트 필터링이 더 적합하지만, 대규모라 가정하고 구현할 생각이기 때문에 검색창에 입력하는 검색어를 포함한 값만 API로 요청해서 구현하기로 했다.

- 검색창에 입력하는 중
  - 일치하는 유저를 최대 5개 보여준다.
  - 디바운싱을 통해 300ms마다 요청을 보낸다.
- 검색창에 입력을 완료하면
  - 일치하는 모든 유저 정보를 보여준다.

**1. 검색 중 데이터를 찾을 때 발생하는 문제**

영어를 검색할 때는 관계 없지만, 한글로 된 데이터는 ㅇ을 검색하게 되면 이름에 ㅇ이 들어가도 찾아주지 못하는 문제가 있다.

> Hangul-js를 사용해서 한글 검색어를 모두 분리했다. 예를 들어 검색어는 `안녀`이고 데이터가 `안녕하세요`가 있다면 해당 라이브러리는 `안녀`라는 검색어를 `ㅇㅏㄴㄴㅕ`로 분리한다. 그리고 `안녕하세요` 데이터도 `ㅇㅏㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ`로 분리되기 때문에 입력 중이던 글자로도 데이터를 찾을 수 있게 된다.

**2. 아무것도 입력하지 않았을 때**

아무것도 입력하지 않고 검색했을 때 모든 사용자를 보여주는 것이 맞다고 생각했다. 그러나 검색 중에 자동완성으로 보여주는 것은 모든 데이터를 보여주는(다는 아니라도 상위 몇개만 잘라서 보여주는) 것이 맞을지 고민되었다.

> 실제 서비스들을 살펴본 결과 인기 검색어를 보여주는 방식이지, 데이터를 일부 잘라서 보여주는 방식은 아니었다. 그런데 사용자를 검색하는 것이고 검색량을 저장하는 기능은 없기 때문에 아무것도 입력되지 않을 때 자동 완성 기능은 동작하지 않도록 결정했다.

### 3. 컴포넌트 설계
index.tsx에 다음과 같이 컴포넌트가 존재한다.
```
<검색 창/>
<검색 결과/>
```
- `검색 창` 컴포넌트는 사용자의 검색어를 확인하고 입력 중 자동 완성 기능을 제공한다.
  - 검색 창 컴포넌트 내부는 검색어를 입력 받는 input과 자동 완성 리스트를 보여주는 컴포넌트로 이루어져있다.
  - fetch를 통해 자동 완성을 제공하기 위해 입력 중 단어에 대해 get 요청을 보내 데이터를 가져온다.
- `검색 결과` 컴포넌트는 사용자가 검색어를 입력하고 엔터 키를 눌렸을 때 결과를 보여준다.
  - fetch를 통해 검색한 결과에 대한 데이터를 받아와 보여줘야한다.

**해당 설계에서 아쉬운 점**
- `검색 창`에서 엔터 키를 눌렀을 때 이벤트 처리를 하게 된다.
- 그렇다면 검색 결과를 보여주기 위해 검색 창에서 데이터를 받아와 저장한 것을 검색 결과가 사용할 수 있게 해야한다.

**개선할 수 있는 방법**
상태를 부모 컴포넌트에서 관리한다.
- 부모 컴포넌트가 검색하고 있는 검색어의 상태와 검색할 최종 검색어를 관리한다.
- 검색 창과 검색 결과 컴포넌트에 props로 전달한다.


---

## 🛜 MSW
> `MSW(Mock Service Worker)`는 가짜 API를 만들어 fetch 요청을 가로채서 응답을 반환해주는 라이브러리다.

**설치**

``` bash
npm install msw@1
```
최신 버전은 CommonJS 형식으로 작성해줘야하기 때문에 이전 버전으로 설치했다.

### 왜 필요할까?
- 백엔드가 없을 때도 개발을 가능하게 한다.
- 테스트 시 서버 없이도 시나리오 재현이 가능하다.
- fetch, axios 등 실제 네트워크 요청을 쓰듯이 코드 작성이 가능하다.

### handler와 browser

**handler**: 어떤 요청을 가로챌지 정의
```ts
rest.get("/api/users", (req, res, ctx) => {
  return res(
    ctx.status(200),
    ctx.json([
      반환할 데이터
    ])
  )
})
```

**browser**: 요청을 가로채는 가짜 서버 실행 설정
```ts
export const worker = setupWorker(...handlers);
```

- setupWorker: 브라우저에서 동작하는 가짜 서비스 워커를 설정한다.
- 내부적으로 Service Worker API를 이용해 브라우저 레벨에서 fetch 요청을 가로챈다.

```tsx
if (import.meta.env.DEV) {
  const { worker } = await import('./browser.ts');
  await worker.start();
}
```

- 앱의 진입 점에 해당 코드를 작성해준다.
- 개발 모드에서 서비스 워커를 실행하는 코드이다.

### MSW에서 다양한 쿼리 파라미터에 대한 응답 처리
> 요청에서 쿼리 파라미터를 읽어 정렬해줄 수 있다.

클라이언트가 다음과 같이 요청을 보낸다.

```bash
GET /api/users?sort=name&order=asc
```

유저 정보를 이름 순으로 오름차순 정렬로 가져온다.

```ts
rest.get("/api/users", (req, res, ctx) => {
  const sort = req.url.searchParams.get("sort");
  const order = req.url.searchParams.get("order");

  const sortedUsers = [...mockUsers].sort((a, b) => {
    if (sort === "name") {
      return order === "desc"
        ? b.name.localeCompare(a.name)
        : a.name.localeCompare(b.name);
    }
    return 0;
  });

  return res(ctx.status(200), ctx.json(sortedUsers));
});
```

### 다른 도구와의 차이

1. fetch 없이 직접 mock 데이터를 사용하는 경우
- fetch를 사용하지 않기 때문에 이후 API 서버가 개발되고 나면 코드 수정을 해야한다.
- 빠르게 화면을 그릴 수 있다는 장점이 있지지만, 로딩/에러 처리 등 비동기 흐름을 테스트하기 어렵다.

2. lowdb
- 네트워크 레벨에서 요청을 가로채는 것이 불가능하다.
- API 서버가 아니기 때문에 fetch 요청은 직접 서버 코드를 작성해야 사용 가능하다.
- 클라이언트와 바로 연결은 어렵고 Express 등과 함께 사용해야 유용하다.

3. json-server
- fetch 요청을 통해 실제 API 요청과 같이 작성할 수 있다.
- 복잡한 조건 로직 구현이 어려워, 조건부 필터와 같은 요청은 할 수 없다.
- 테스트할 때마다 서버를 띄워야한다.

**MSW**
- fetch, axios 그대로 사용 가능하기 때문에, API 교체 시 코드 수정이 없다.
- 조건부 응답 로직을 사용할 수 있다.
- 로딩, 에러, 타임아웃 등 다양한 상황을 시뮬레이션 가능하다.
- 클라이언트 코드에 가짜 서버를 붙이는 것처럼 작동한다.

## ⏰ 디바운싱(Debouncing)
> 짧은 시간 내에 연속적으로 발생하는 이벤트가 있을 때, 마지막 이벤트만 처리하도록 지연시키는 방식으로 불필요한 요청을 줄이는데 사용한다.

**코드 예시**

```tsx
function useDebounce(value, delay = 300) {
  const [debounced, setDebouced] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebounced(value), delay);
    return () => clearTimeout(timer);
  }, [value, delay]);

  return debounced;
}
```

```tsx
const [search, setSearch] = useState('');
const debouncedSearch = useDebounce(search, 300);

useEffect(() => {
  if (!debouncedSearch) return;
  fetch(`/api/users?search=${debouncedSearch}`)
    .then(res => res.json())
    .then(setUsers);
}, [debouncedSearch]);
```

- useDebounce 훅은 search 값이 바뀔 때마다 300ms동안 아무 입력이 없을 때만 debouncedSearch 값을 갱신한다.
- 사용자가 타이핑을 멈춘 후 300ms가 지나야 실제 API 요청을 위한 값이 변경된다.

> 디바운싱과 달리 스로틀링은 일정 주기마다 실행하는 것으로, 스크롤이나 리사이즈 이벤트가 발생할 때 사용한다.